<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Optimizing</title>
    <script src="../draw_layout.js"></script>
    <script src="../chapter/22_fast.js"></script>
  </head>
  <body>
    <!-- Optimizing

    Now that you have measurements for a test case, try to find ways to make findPath faster.

    Consider both macro-optimization (doing less work) and micro-optimization (doing the given work in a less costly way). Also look for ways to use less memory and allocate fewer or smaller data structures. -->

    <script>
      function time(findPath) {
        let graph = treeGraph(6, 6);
        let startTime = Date.now();
        let result = findPath(graph[0], graph[graph.length - 1]);
        console.log(
          `Path with a length of ${result.length} was found in ${
            Date.now() - startTime
          } ms`
        );
      }

      function findPath(a, b) {
        let work = [[a]];
        for (let path of work) {
          let end = path[path.length - 1];
          if (end == b) return path;
          for (let next of end.edges) {
            if (!work.some(path => path[path.length - 1] == next)) {
              work.push(path.concat([next]));
            }
          }
        }
      }
      // time(findPath);
      // → Path with a length of 6 was found in 859 ms

      // macro-optimization (doing less work)
      function findPath_set(a, b) {
        let work = [[a]];
        let reached = new Set([a]);
        for (let path of work) {
          let end = path[path.length - 1];
          if (end == b) return path;
          for (let next of end.edges) {
            if (!reached.has(next)) {
              reached.add(next);
              work.push(path.concat([next]));
            }
          }
        }
      }
      // time(findPath_set);
      // → Path with a length of 6 was found in 23 ms

      // micro-optimization (doing the given work in a less costly way)
      // look for ways to use less memory and allocate fewer or smaller data structures
      // path {at: GraphNode, via: {at: GraphNode, via: {at: GraphNode, via: null}}}
      function pathToArray(path) {
        let result = [];
        for (; path; path = path.via) {
          result.unshift(path.at);
        }
        return result;
      }

      function findPath_list(a, b) {
        let work = [{at: a, via: null}];
        let reached = new Set([a]);
        for (let path of work) {
          if (path.at == b) return pathToArray(path);
          for (let next of path.at.edges) {
            if (!reached.has(next)) {
              reached.add(next);
              work.push({at: next, via: path});
            }
          }
        }
      }
      time(findPath_list);
      // → Path with a length of 6 was found in 17 ms
    </script>
  </body>
</html>
