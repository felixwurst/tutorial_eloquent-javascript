<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Proper Lines</title>
  </head>
  <script src="../code/chapter/19_paint.js"></script>

  <body>
    <!-- This is a more advanced exercise than the preceding two, and it will require you to design a solution to a nontrivial problem. Make sure you have plenty of time and patience before starting to work on this exercise, and do not get discouraged by initial failures.

    On most browsers, when you select the draw tool and quickly drag across the picture, you don’t get a closed line. Rather, you get dots with gaps between them because the "mousemove" or "touchmove" events did not fire quickly enough to hit every pixel.

    Improve the draw tool to make it draw a full line. This means you have to make the motion handler function remember the previous position and connect that to the current one.

    To do this, since the pixels can be an arbitrary distance apart, you’ll have to write a general line drawing function.

    A line between two pixels is a connected chain of pixels, as straight as possible, going from the start to the end. Diagonally adjacent pixels count as a connected. So a slanted line should look like the picture on the left, not the picture on the right.

    Finally, if we have code that draws a line between two arbitrary points, we might as well use it to also define a line tool, which draws a straight line between the start and end of a drag. -->

    <div></div>
    <script>
      // previous version
      // function draw(pos, state, dispatch) {
      //   function drawPixel({x, y}, state) {
      //     let drawn = {x, y, color: state.color};
      //     dispatch({picture: state.picture.draw([drawn])});
      //   }
      //   drawPixel(pos, state);
      //   return drawPixel;
      // }

      //   // let x = drawn[done].x + dx,
      //   //   y = drawn[done].y + dy;
      //   // if (
      //   //   x >= 0 &&
      //   //   x < state.picture.width &&
      //   //   y >= 0 &&
      //   //   y < state.picture.height &&
      //   //   state.picture.pixel(x, y) == targetColor &&
      //   //   !drawn.some(p => p.x == x && p.y == y)
      //   // ) {
      //   //   drawn.push({x, y, color: state.color});
      //   // }
      // }

      function draw(pos, state, dispatch) {
        let previousPos = null;
        function drawPixel({x, y}, state) {
          console.log(previousPos, x, y);

          function findNearest(x, y) {
            // the eight pixels adjacent to the selected pixel
            const around = [
              {dx: -1, dy: -1},
              {dx: 0, dy: -1},
              {dx: 1, dy: -1},
              {dx: -1, dy: 0},
              {dx: 1, dy: 0},
              {dx: -1, dy: 1},
              {dx: 0, dy: 1},
              {dx: 1, dy: 1},
            ];
            let dist = 100;
            let nearest;
            for (let {dx, dy} of around) {
              let aroundX = x + dx,
                aroundY = y + dy;
              if (previousPos) {
                let currentDist = Math.sqrt(
                  Math.pow(aroundX - previousPos.x, 2) +
                    Math.pow(aroundY - previousPos.y, 2)
                );
                if (currentDist < dist) {
                  nearest = {x: aroundX, y: aroundY};
                  dist = currentDist;
                }
              }
            }
            if (previousPos.x == nearest.x && previousPos.y == nearest.y) {
              return drawn;
            }
            drawn.push({x: nearest.x, y: nearest.y, color: 'red'});
            return findNearest(nearest.x, nearest.y);
          }

          let drawn = [{x, y, color: state.color}];
          if (previousPos) {
            drawn = findNearest(x, y);
            console.log(drawn);
          }
          dispatch({picture: state.picture.draw(drawn)});
          previousPos = {x, y};
        }
        drawPixel(pos, state);
        return drawPixel;
      }

      // function rectangle(start, state, dispatch) {
      //   function drawRectangle(pos) {
      //     let xStart = Math.min(start.x, pos.x);
      //     let yStart = Math.min(start.y, pos.y);
      //     let xEnd = Math.max(start.x, pos.x);
      //     let yEnd = Math.max(start.y, pos.y);
      //     let drawn = [];
      //     for (let y = yStart; y <= yEnd; y++) {
      //       for (let x = xStart; x <= xEnd; x++) {
      //         drawn.push({x, y, color: state.color});
      //       }
      //     }
      //     dispatch({picture: state.picture.draw(drawn)});
      //   }
      //   drawRectangle(start);
      //   return drawRectangle;
      // }

      function line(start, state, dispatch) {
        function drawLine(pos) {
          let xStart = Math.min(start.x, pos.x);
          let yStart = Math.min(start.y, pos.y);
          let xEnd = Math.max(start.x, pos.x);
          let yEnd = Math.max(start.y, pos.y);
          let drawn = [];

          for (let y = yStart; y <= yEnd; y++) {
            for (let x = xStart; x <= xEnd; x++) {
              drawn.push({x, y, color: state.color});
            }
          }

          dispatch({picture: state.picture.draw(drawn)});
        }
        drawLine(start);
        return drawLine;
      }

      let dom = startPixelEditor({
        tools: {draw, line, fill, rectangle, pick},
      });
      document.querySelector('div').appendChild(dom);
    </script>
  </body>
</html>
